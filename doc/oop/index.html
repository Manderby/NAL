<!DOCTYPE HTML>
<html lang="de">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="../css.css"/>
</head>
<body>


<a href="../index.html">&lt;-- back</a>

<h1>Object oriented Programming</h1>

<p>OOP in NAL shall be single inheritance.</p>



<h2>Basic class/struct definition</h2>

<div class="twoCodes">
  <code>
    NAL:
    
    // Example uses a base type (just for example purposes):
    
    BaseType = module;
    
    .drink = f32 (mutable this, f32 percentage);  // pure virtual
    
    
    
    Bottle = module : BaseType;
    
    volume = f32(1.);      // auto initialized value
    fluid = string;        // uninitialized value
    broken = bool(false);  // auto initialized value

    .constructor = (mutable this, fluid string) { // public method
      .fluid = fluid; // dot operator, same as this.fluid
    }

    .create (string fluid) {  // public static function
      return new Bottle(fluid);
    }

    .destructor = (mutable Bottle) {
      // do destructor stuff.
    }
    
    .drink = f32 (mutable this, f32 percentage) {
      BaseType.drink(percentage);
      volume *= 1. - percentage;
      return volume;
    }

    dropOnTheFloor = (mutable this) {
      broken = true;
      volume = 0.;
    }

    ... implementation part
    
    {
      bottle1 = Bottle("orange juice");         // using constructor
      bottle2 = Bottle.create("orange juice");  // using static method
      fluidLeft = bottle1.drink(0.44);
    }
  </code>
  <code>
    C:
    struct Bottle {
      BaseType _base;
      float volume;
      const char* fluid;
      bool broken;
    };
    
    float _nal_Bottle_constructor(Bottle* this, const char* fluid) {
      this->volume = 1.;
      strncpy(this->fluid, fluid, strlen(fluid)); // todo: compiler must check for const.
      this->broken = false;
    }
    
    float _nal_Bottle_destructor(Bottle* this) {
      // do destructor stuff.
    }

    float _nal_Bottle_drink(Bottle* this, float percentage) {
      _nal_BaseType_drink((BaseType*)this);
      this->volume *= 1. - percentage;
      return this->volume;
    }

    float _nal_Bottle_dropOnTheFloor(Bottle* this) {
      this->broken = true;
      this->volume = 0.;
    }
    
    {
      Bottle bottle;
      _nal_Bottle_constructor(bottle, "orange juice");
      float fluidLeft = _nal_Bottle_drink(&bottle, 4.44f);
    }
  </code>
</div>

<h3>Discussion</h3>

<ul>
<li><code>this</code> must be declared explicitely as the first parameter.</li>
<li>public and private functions/methods are defined by the dot:

<code>
myNormalFunction        = bool (i32 myParameter) {return true;}
.myPublicStaticFunction = bool (i32 myParameter) {return true;}
myPrivateMethod         = bool (this, i32 myParameter) {return true;}
.myPublicMethod         = bool (this, i32 myParameter) {return true;}
</code>

<li>public and private variables/members are defined by the dot. Static members are always private and have to be explicitely marked with the module keyword:

<code>
myPrivateMember = bool;  // private member
.myPublicMember = bool;  // public member
</code>

<li>There are no static members. There are globals which need to be defined BEFORE any module definition. This means that the terrible, sinful and absolutely dissed global variables are explicitely allowed (because the so sophisticated and praised statics are nothing but private global variables and everybody which says otherwise is lying to itself). Good practice is to never define a public global variable but to define a static function inside a module which returns the private global variable defined in the same implementation file. The reason for allowing any global variable is that a lot of programmers do not want to create complicated modules but just want a simple program that does a job. Also embedded programmers sometimes just want a short, 200 loc program. They do not want and need restrictions. If they want to shoot themselfes into the foot, so be it.

<code>
// Before any xxx = module definition:
myPrivateGlobalVariable = bool;
.myPublicGlobalVariable  = bool;
</code>

<li>All public methods are automatically virtual. Allow method to be pure by simply omitting the <code>{}</code>.</li>
<li>Maybe use <code>mut</code> instead of <code>mutable</code>.</li>
</ul>



<h2>Extensions</h2>

<p>All types shall be extensible by allowing the programmer to define Extensions and implement them. When implementing an extension inside of the implementation file where the type is declared, one has access to its private properties. Outside, only the public properties are available.</p>

<p>Advantage: An extension can be added at any place from anybody. It allows for rapid development of new features. A class which is not accessible privately can at least be molded into an interface which supports the methods of the extension. This is as easy as defining a method with a specific type for the <code>this</code> pointer:</p>

<div class="twoCodes">
  <code>
    NAL:
    
    Refillable = module;
    
    .refill (mutable this);  // no implementation = pure virtual
    
    ... extension if in the same file as definition of module Bottle:
    
    .refill(mutable Bottle this) {  // this now refers to a Bottle
      if(broken)                  // access to private member
        printf("Cannot refill.");
      else
        volume = 1.;              // access to private member
    }
        
    ... implementation part
    
    {
      bottle = Bottle("IceTea");
      bottle.drink(.5);
      bottle.refill();
    }
  </code>
  <code>
    C:
    float _nal_Refillable_extends_Bottle_refill(Bottle* this) {
      if(this->broken)
        printf("Cannot refill.");
      else
        this->volume = 1.;
    }

    {
      Bottle bottle;
      ... // instantiation as above + calling drink
      _nal_Refillable_extends_Bottle_refill(&bottle);
    }
  </code>
</div>



</body>
</html>
