<!DOCTYPE HTML>
<html lang="de">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="css.css"/>
</head>
<body>



<p>This is a living document for NAL (Not A Language).</p>

<p>NAL shall be a language with the mindeset of C but safe and syntactically improved. Simpler, more readable, more streamlined. More restrictive but more straight-forward.</p>

<p>Goto <a href="https://github.com/Manderby/NAL">GitHub</a> to find this document.</p>

<p>Feel free to contribute. Discussions are what this is all about. It's fun to dream things!</p>



<h2>Target groups</h2>

<ul>
<li>Target groups: Application programmers, Embedded programmers. Programming beginners.</li>
<li>Not a target group: System programming. Too complicated. No chance this will ever work completely safe.</li>
</ul>




<h2>Iron rules</h2>

<ul>
<li>keywords do never contain underscores.</li>
<li>keywords are always lowercase only.</li>
</ul>



<h2>Quality goals</h2>

<ul>
<li>The language may improve over time with different versions. The language hasn't got the urge to be backwards compatible but strives to do so.</li>
<li>Compiler error messages must be easy to read.</li>
<li>Forward declarations not necessary. Someting like C-Header files including comments which are right before defined symbols will be automatically generated upon compilation. Needs proper definition of what is a "header" comment.</li>
<li>Includes shall be detected or found by the compiler automatically. Requires common rules on how to find implementation/header files. Maybe belongs to the build system. Needs further thinking.</li>
<li>PIMPL must be prevented. Having no header files would already guarantee this.</li>
<li>Try to recuce special characters like <code>!~\&lt;&gt;@|&amp;^./?_%</code> as much as possible! If a further version adds extensions, better break an old functionality than adding a new character.</li>
<li>No implicit constructors, desctructors, converters, ... What you code is what you get.</li>
<li>Do not allow insecure methods. scanf is one of the culprits.</li>
</ul>



<h2>Things to throw away from C</h2>

<ul>
<li>See <a href="throwaway/index.html">Here</a>.</li>
</ul>



<h2>New Concepts</h2>

<ul>
<li><a href="rangefor/index.html">Range <code>for</code></a></li>
<li><a href="bleedkeyword/index.html"><code>bleed</code> Keyword</a></li>
<li><a href="oop/index.html">OOP</a></li>
<li><a href="ownership/index.html">Ownership</a></li>
<li>Parameters passed to a method/function are const by default. All parameters can be made non-const by using the <code>mutable</code> keyword. If changing a variable and passing it back to the calling scope is required, use the <code>bleed</code> keyword.</li>
<li>Parameter passing:
  <ul>
    <li>simple types like i32, f64, letter, .... are passed as values.</li>
    <li>Objects are passed as pointers and are dereferenced automatically in the inner scope.</li>
  </ul></li>
<li>For a later version: Add yield and coroutine functionality. Needs a lot of research still as I do not really know anything about it, but it sounds very fascinating.</li>
</ul>



<h2>Other topics</h2>

<ul>
<li>Namespaces. There are two levels. One is the module which can be defined by the module keyword in one file. Another is based on the project system. One defines in a configuration file what modules belong to what package. Loaded packages can be in a custom namespace.</li>
<li>Discarded: Type and variable declaration/definition was proposed to put the variable first, then the type. But it introduced lots of syntactical problems.</li>
<li>Discarded: Can we omit the semicolon. Is optional in other languages, but might server better readability. Maybe only omit it for declarartions inside of a struct/class. Discarded because it helps to keep the code deterministic.</li>
</ul>



<h2>Type-System</h2>

<ul>
<li>Strong typing.</li>
<li>New type: "byte" ?</li>
<li>New integer types: i8, i16, i32, i64, ... u8, u16, u32, u64, ...</li>
<li>New keyword "letter" for characters. Preferably UTF-8</li>
<li>New types "f32" and "f64" which repalce float and double.</li>
<li>New type "bool", new keywords "true" and "false"</li>
<li>Make array a native type (name under discussion. Some like vec but its frowned upon my most. Namespaces are problematic here as well). Proposition for syntax: array[i32, 6] whereas i32 is a type and 6 is the number of elements in the array. An array is fixed size.</li>
<li>Type of index variable is size_t in C needs a counterpart in NAL. Needs a printf formatter %i.</li>
<li>Make string a native type. Suggestion: Use UTF-8 as default. Can be extended later.</li>
</li>
<li>About structs: Replace it with <a href="oop/index.html">OOP</a> concept.</li>
<li>All types are automatically typedef'd.</li>
<li>Casts are NOT allowed. Except: dynamic casts using something like [someObject CastType]. Requires classes to store some kind of a type id given at runtime. Objects are casted automatically to their base type if the base type is requested. Basic types like f32 need converter methods like .toI32().</li>
<li>Templates are not needed. Extending classes with Interfaces is better. Needs discussion.</li>
<li>Initialization is the same as the assignment operator. Therefore <code>i = i32(5)</code> is the same as <code>i32 i(5)</code></li>
<li>nullptr exists. nullptr must be compatible with any object type. Required for dynamic casts.</li>
<li>Add index/iterator type. Proposition: <code>[]</code>.
</li>
</ul>



<h2>Other ideas</h2>
<ul>
<li>Function overloading could be cool. Easy to do with name mangling. But adds complexity. Maybe in a later version.</li>
<li>Disallow standard parameters.</li>
<li>No ascii mode for file input or output.</li>
<li>Promote using less <code>{}</code>. Probably not a good idea to remove them all. Make them optional where useful.</li>
<li>Variables are NOT initialized automatically.</li>
<li>The operators <code>&amp;=</code> <code>|=</code> and <code>^=</code> should be extended to boolean values.</li>
<li>The operators <code>&amp;&amp;</code> and <code>||</code> are to be replaced with <code>&amp;</code> and <code>|</code>. Due to strong typing, that should not be an issue</li>
<li>The operators <code>==</code> might be replaced with <code>=</code>. Might.</li>
<li>Assignment operators have no return value. So no <code>a = b = c</code> possible.</li>
<li>Add named parameters. Optional. Sytax with colons: instead of .dots</li>
<li>Variable shadowing is an error, not a warning. In constructors, the dot operator helps distinguishing between parameter and member.</li>
<li>Disallow void*. Add customType with runtime code generation with declareWithType.</li>
<li>No templates otherwise. Think about it. Have no real idea yet how.</li>
<li>Variadic initialization. Needs discussion. Probably not</li>
<li>Variadic arguments ... are not allowed anymore. Define built-in printf.</li>
<li>exception handling?</li>
<li>build system included in compiler. Builds "makefiles" automatically. Manages all dependencies of a project.</li>
<li>compilerflags: target like x86_64-unknow-linux-gnu</li>

</ul>



<h2>Examples submitted by viewers:</h2>
<li>Syntax examples of why Rust is worse than C: <a href="https://pastebin.com/c7gvYAWC">Link</a>.</li>




</body>
</html>
